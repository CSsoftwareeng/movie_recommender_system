package com.recommend.app;

import java.util.*;
import org.junit.Assert;
import org.junit.Test;

public class MovieTest {

  @Test
  public void testConstructor() {
    Movie movie = new Movie("title", "genres", "imdb");
    Assert.assertEquals("title", movie.getTitle());
    Assert.assertEquals("genres", movie.getGenres());
    Assert.assertEquals("imdb", movie.getImdb());
  }
}

package com.recommend.app;

import java.util.*;
import org.junit.Assert;
import org.junit.Test;

public class RatingTest {

  @Test
  public void testGetSum() {
    Rating rating = new Rating(10, 5, 2);
    Assert.assertEquals(rating.getSum(), 10);
  }

  @Test
  public void testGetCount() {
    Rating rating = new Rating(10, 5, 2);
    Assert.assertEquals(rating.getCount(), 5);
  }

  @Test
  public void testGetAverage() {
    Rating rating = new Rating(10, 5, 2);
    int exp = (int) 2.0;
    int act = (int) rating.getAverage();
    Assert.assertEquals(exp, act);
  }

  @Test
  public void testGetMatch() {
    Rating rating = new Rating(10, 5, 2);
    Assert.assertEquals(rating.getMatch(), 2);
  }

  @Test
  public void testCompareTo() {
    Rating rating1 = new Rating(10, 2, 2);
    Rating rating2 = new Rating(10, 5, 3);
    Rating rating3 = new Rating(10, 2, 3);
    Rating[] arr = new Rating[] { rating1, rating2, rating3 };
    Arrays.sort(arr);
    Assert.assertEquals(rating1, arr[0]);
    Assert.assertEquals(rating2, arr[1]);
    Assert.assertEquals(rating3, arr[2]);
  }
}

package com.recommend.app;

import java.util.*;
import org.junit.Assert;
import org.junit.Test;

public class AvgRatingTest {

  @Test
  public void testMethods() {
    AvgRating rating = new AvgRating(10, 5);
    Assert.assertEquals(10, rating.getSum());
    Assert.assertEquals(5, rating.getCount());
    rating.setAverage();
    Assert.assertTrue(rating.getAverage() == 2.0);
  }
}

package com.recommend.app;

import static org.hamcrest.Matchers.containsString;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

@SpringBootTest
@AutoConfigureMockMvc
public class UsersBasedRecommControllerTest {

  @Autowired
  private MockMvc mvc;

  @Test
  public void testValidRequest() throws Exception {
    String json =
      "{\"gender\" : \"\", \"age\" : \"\", \"occupation\" : \"\", \"genres\" : \"Romance|comedy\"}";

    mvc
      .perform(
        get("/users/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isOk())
      .andExpect(jsonPath("$.length()").value(10));
  }

  @Test
  public void testValidRequestWithFullConditions() throws Exception {
    String json =
      "{\"gender\" : \"F\", \"age\" : \"30\", \"occupation\" : \"artist\", \"genres\" : \"Romance|comedy\"}";

    mvc
      .perform(
        get("/users/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isOk())
      .andExpect(jsonPath("$.length()").value(10));
  }

  @Test
  public void testValidRequestWoGenres() throws Exception {
    String json = "{\"gender\" : \"\", \"age\" : \"\", \"occupation\" : \"\"}";

    mvc
      .perform(
        get("/users/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isOk())
      .andExpect(jsonPath("$.length()").value(10));
  }

  @Test
  public void testTooFewArguments() throws Exception {
    String json = "{\"occupation\" : \"\", \"genres\" : \"Romance|comedy\"}";

    mvc
      .perform(
        get("/users/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isBadRequest())
      .andExpect(status().reason(containsString("ArgCntError")));
  }

  @Test
  public void testTooManyArguments() throws Exception {
    String json =
      "{ \"gender\" : \"\", \"age\" : \"\", \"occupation\" : \"\", \"genres\" : \"Romance|comedy\", \"DUMMY_FILED\" : \"DUMMY_STRING\"}";

    mvc
      .perform(
        get("/users/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isBadRequest())
      .andExpect(status().reason(containsString("ArgCntError")));
  }

  @Test
  public void testWrongArguments() throws Exception {
    String json =
      "{ \"gender\" : \"\", \"age\" : \"\", \"occupation\" : \"\", \"INVALID_FILED\" : \"INVALID_STRING\"}";

    mvc
      .perform(
        get("/users/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isBadRequest())
      .andExpect(status().reason(containsString("WrongArgError")))
      .andExpect(status().reason(containsString("gender, age, occupation, genres")));;
  }

  @Test
  public void testInvalidAge() throws Exception {
    String json =
      "{\"gender\" : \"\", \"age\" : \"-1\", \"occupation\" : \"\", \"genres\" : \"Romance|comedy\"}";

    mvc
      .perform(
        get("/users/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isBadRequest())
      .andExpect(status().reason(containsString("age")));
  }

  @Test
  public void testInvalidGender() throws Exception {
    String json =
      "{\"gender\" : \"Q\", \"age\" : \"\", \"occupation\" : \"\", \"genres\" : \"Romance|comedy\"}";

    mvc
      .perform(
        get("/users/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isBadRequest())
      .andExpect(status().reason(containsString("gender")));
  }

  @Test
  public void testInvalidOccupation() throws Exception {
    String json =
      "{\"gender\" : \"\", \"age\" : \"\", \"occupation\" : \"Q\", \"genres\" : \"Romance|comedy\"}";

    mvc
      .perform(
        get("/users/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isBadRequest())
      .andExpect(status().reason(containsString("occupation")));
  }

  @Test
  public void testMissingArgument() throws Exception {
    String jsonMissingAge =
      "{\"gender\" : \"\", \"occupation\" : \"\", \"genres\" : \"Romance|comedy\"}";
    String jsonMissingGender =
      "{\"age\" : \"\", \"occupation\" : \"\", \"genres\" : \"Romance|comedy\"}";
    String jsonMissingOccupation =
      "{\"gender\" : \"\", \"age\" : \"\", \"genres\" : \"Romance|comedy\"}";

    mvc
      .perform(
        get("/users/recommendations")
          .content(jsonMissingAge)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isBadRequest())
      .andExpect(status().reason(containsString("'age' is missing")));

    mvc
      .perform(
        get("/users/recommendations")
          .content(jsonMissingGender)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isBadRequest())
      .andExpect(status().reason(containsString("'gender' is missing")));

    mvc
      .perform(
        get("/users/recommendations")
          .content(jsonMissingOccupation)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isBadRequest())
      .andExpect(status().reason(containsString("'occupation' is missing")));
  }
}

package com.recommend.app;

import static org.hamcrest.Matchers.containsString;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.Assert;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;

@SpringBootTest
@AutoConfigureMockMvc
public class MovieBasedRecommControllerTest {

  @Autowired
  private MockMvc mvc;

  @Test
  public void testValidRequest() throws Exception {
    String json = "{\"title\" : \"Toy Story (1995)\", \"limit\" : 20}";

    mvc
      .perform(
        get("/movies/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isOk())
      .andExpect(jsonPath("$.length()").value(20));
  }

  @Test
  public void testValidRequestWoYear() throws Exception {
    String jsonWithYear = "{\"title\" : \"Toy Story (1995)\", \"limit\" : 20}";
    String jsonWoYear = "{\"title\" : \"Toy Story\", \"limit\" : 20}";

    MvcResult resultWithYear = mvc
      .perform(
        get("/movies/recommendations")
          .content(jsonWithYear)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andReturn();

    String contentWithYear = resultWithYear.getResponse().getContentAsString();

    MvcResult resultWoYear = mvc
      .perform(
        get("/movies/recommendations")
          .content(jsonWoYear)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andReturn();

    String contentWoYear = resultWoYear.getResponse().getContentAsString();

    Assert.assertEquals(contentWithYear, contentWoYear);
  }

  @Test
  public void testValidRequestWithExtremeLimit() throws Exception {
    String json = "{\"title\" : \"Toy Story (1995)\", \"limit\" : 4000}";

    mvc
      .perform(
        get("/movies/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isOk());
  }

  @Test
  public void testValidRequestWoLimit() throws Exception {
    String json = "{\"title\" : \"Toy Story (1995)\"}";

    mvc
      .perform(
        get("/movies/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isOk())
      .andExpect(jsonPath("$.length()").value(10));
  }

  @Test
  public void testTooFewArguments() throws Exception {
    String json = "{}";

    mvc
      .perform(
        get("/movies/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isBadRequest())
      .andExpect(status().reason(containsString("ArgCntError")));
  }

  @Test
  public void testInvalidTitle() throws Exception {
    String json = "{\"title\" : \"INVALID_STRING\", \"limit\" : 20}";

    mvc
      .perform(
        get("/movies/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isNotFound())
      .andExpect(status().reason(containsString("MovieNotExistError")));
  }

  @Test
  public void testWrongArguments() throws Exception {
    String json = "{\"title\" : \"INVALID_STRING\", \"INVALID_FILED\" : \"INVALID_STRING\"}";

    mvc
      .perform(
        get("/movies/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isBadRequest())
      .andExpect(status().reason(containsString("WrongArgError")))
      .andExpect(status().reason(containsString("title, limit")));
  }

  @Test
  public void testMissingTitle() throws Exception {
    String json = "{\"limit\" : 20}";

    mvc
      .perform(
        get("/movies/recommendations")
          .content(json)
          .contentType(MediaType.APPLICATION_JSON)
      )
      .andExpect(status().isBadRequest())
      .andExpect(status().reason(containsString("ArgMissingError")));
  }
}

package com.recommend.app;

import java.util.*;
import org.junit.Assert;
import org.junit.Test;

public class RatingCalculatorTest {

  @Test
  public void testrankUserBasedRating() {
    List<String> genres = new ArrayList<String>();
    genres.add("Romance");

    MovieList movielist = new MovieList(genres);
    UserList userlist = new UserList();
    userlist.searchSimilarUser("F", "30", "artist");

    RatingCalculator rating = new RatingCalculator(movielist, userlist);
    rating.rankUserBasedRating(10);
    rating.calcResult();
    Assert.assertEquals(10, rating.numMoviesResult());
    Assert.assertEquals(10, rating.moviesResult.size());
  }

  @Test
  public void testrankGenreBasedRating() {
    String title = "Toy Story (1995)";

    MovieList movielist = new MovieList();
    UserList userlist = new UserList();

    movielist.registerFavoriteMovie(title);
    userlist.searchFavoriteUsers(title);

    RatingCalculator rating = new RatingCalculator(movielist, userlist);
    rating.rankGenreBasedRating(20, true);
    rating.calcResult();
    Assert.assertEquals(20, rating.numMoviesResult());
    Assert.assertEquals(20, rating.moviesResult.size());
  }
}

package com.recommend.app;

import com.recommend.utils.errors.MovieNotExistError;
import java.util.*;
import org.junit.Assert;
import org.junit.Test;

public class ToolTest {

  @Test(expected = MovieNotExistError.class)
  public void testGetMovieGenreNotExistMovie() {
    Tool.getMovieGenre("NOT_EXIST_MOVIE_TITLE");
  }

  @Test
  public void testGetMovieGenre() {
    List<String> Genres = new ArrayList<String>();
    Genres.add("Animation");
    Genres.add("Children's");
    Genres.add("Comedy");
    Assert.assertEquals(Tool.getMovieGenre("Toy Story (1995)"), Genres);
  }

  @Test(expected = MovieNotExistError.class)
  public void testGetMovieIdNotExistMovie() {
    Tool.getMovieID("NOT_EXIST_MOVIE_TITLE");
  }

  @Test
  public void testgetMovieID() {
    Assert.assertEquals(Tool.getMovieID("Toy Story (1995)"), 1);
    Assert.assertEquals(Tool.getMovieID("American President, The (1995)"), 11);
    Assert.assertEquals(Tool.getMovieID("Instinct (1999)"), 2676);
  }
}

package com.recommend.app;

import com.recommend.utils.errors.ArgCntError;
import com.recommend.utils.errors.ArgNotExistError;
import java.util.*;
import jdk.jfr.Timestamp;
import org.junit.Assert;
import org.junit.Rule;
import org.junit.Test;

public class ArgumentTest {

  @Test(expected = ArgNotExistError.class)
  public void testArgNotExistErrorGender() {
    Arguments args1 = new Arguments("str_gender", "", "", "Action");
  }

  @Test(expected = ArgNotExistError.class)
  public void testArgNotExistErrorage() {
    Arguments args1 = new Arguments("", "-1", "", "Action");
  }

  @Test(expected = ArgNotExistError.class)
  public void testArgNotExistErrorOccupation() {
    Arguments args1 = new Arguments("", "", "str_occ", "Action");
  }

  @Test(expected = ArgNotExistError.class)
  public void testArgNotExistErrorGenreInvalid() {
    Arguments args1 = new Arguments("", "", "", "str_genre");
  }

  @Test
  public void testSetMap() {
    Arguments args1 = new Arguments();
    args1.setMap();
    Assert.assertEquals("Result", args1.OCCUPATIONS_MAP.size(), 47);
    Assert.assertEquals("Result", args1.GENRE_MAP.size(), 20);
  }

  @Test
  public void testSetArgs() {
    Arguments args1 = new Arguments();
    Arguments args2 = new Arguments();
    args1.setArgs("1", "2", "3");
    args2.setArgs("4", "5", "6", "7");
    Assert.assertEquals("Result", args1.gender, "1");
    Assert.assertEquals("Result", args1.age, "2");
    Assert.assertEquals("Result", args1.raw_occupation, "3");
    Assert.assertEquals("Result", args2.gender, "4");
    Assert.assertEquals("Result", args2.age, "5");
    Assert.assertEquals("Result", args2.raw_occupation, "6");
    Assert.assertEquals("Result", args2.raw_genres, "7");
  }

  @Test
  public void testParseGender() {
    Arguments args1 = new Arguments();
    Arguments args2 = new Arguments();
    Arguments args3 = new Arguments();

    args1.setArgs("f", "25", "Grad student");
    args2.setArgs("m", "25", "Grad student", "Action|Comedy");
    args3.setArgs("", "25", "Grad student");

    args1.parseGender();
    args2.parseGender();
    args3.parseGender();

    Assert.assertEquals("Result", args1.gender, "F");
    Assert.assertEquals("Result", args2.gender, "M");
    Assert.assertEquals("Result", args3.gender, "");
  }

  @Test
  public void testParseAge() {
    Arguments args1 = new Arguments();
    Arguments args2 = new Arguments();
    Arguments args3 = new Arguments();
    Arguments args4 = new Arguments();
    Arguments args5 = new Arguments();
    Arguments args6 = new Arguments();
    Arguments args7 = new Arguments();

    args1.age = "10";
    args2.age = "20";
    args3.age = "30";
    args4.age = "40";
    args5.age = "48";
    args6.age = "52";
    args7.age = "60";

    args1.parseAge();
    args2.parseAge();
    args3.parseAge();
    args4.parseAge();
    args5.parseAge();
    args6.parseAge();
    args7.parseAge();

    Assert.assertEquals("Result", args1.age, "1");
    Assert.assertEquals("Result", args2.age, "18");
    Assert.assertEquals("Result", args3.age, "25");
    Assert.assertEquals("Result", args4.age, "35");
    Assert.assertEquals("Result", args5.age, "45");
    Assert.assertEquals("Result", args6.age, "50");
    Assert.assertEquals("Result", args7.age, "56");
  }

  @Test
  public void testPrintArgs() {
    Arguments args1 = new Arguments("F", "25", "grad student", "action|comedy");
    args1.printArgs();
  }

  @Test
  public void testGetMethods() {
    Arguments args1 = new Arguments("F", "25", "grad student", "action|comedy");
    List<String> expected = Arrays.asList("Action", "Comedy");
    Assert.assertEquals("4", args1.getOccupation());
    Assert.assertEquals(expected, args1.getGenres());
  }
}

package com.recommend.app;

import com.recommend.utils.errors.UserNotExistError;
import org.junit.Assert;
import org.junit.Test;

public class UserListTest {

  @Test(expected = UserNotExistError.class)
  public void testUserNotExistError() {
    UserList userlist = new UserList();
    userlist.searchMatchedUser(21);
  }

  @Test
  public void testSearchMatchedUser() {
    UserList userlist = new UserList();
    userlist.searchMatchedUser(17);
    Assert.assertEquals(userlist.matchedUsers.size(), 502);
    Assert.assertEquals(userlist.mostSimUsers.size(), 0);
    Assert.assertEquals(userlist.lessSimUsers.size(), 0);
    Assert.assertEquals(userlist.notSimUsers.size(), 0);
  }

  @Test
  public void testSearchSimilarUser() {
    UserList userlist = new UserList();
    userlist.searchSimilarUser("F", "25", "4");
    Assert.assertEquals(userlist.matchedUsers.size(), 59);
    Assert.assertEquals(userlist.mostSimUsers.size(), 815);
    Assert.assertEquals(userlist.lessSimUsers.size(), 2757);
    Assert.assertEquals(userlist.notSimUsers.size(), 2409);

    userlist = new UserList();
    userlist.searchSimilarUser("", "", "");
  }

  @Test
  public void testIsMatched() {
    UserList userlist = new UserList();
    userlist.searchSimilarUser("F", "25", "4");
    Assert.assertTrue(userlist.isMatched(219));
    Assert.assertFalse(userlist.isMatched(11));
  }

  @Test
  public void testIsSimilar() {
    UserList userlist = new UserList();
    userlist.searchSimilarUser("F", "25", "4");
    Assert.assertTrue(userlist.isSimilar(11));
    Assert.assertFalse(userlist.isSimilar(219));
  }

  @Test
  public void testIsLessSimilar() {
    UserList userlist = new UserList();
    userlist.searchSimilarUser("F", "25", "4");
    Assert.assertTrue(userlist.isLessSimilar(1));
    Assert.assertFalse(userlist.isLessSimilar(2));
  }

  @Test
  public void testIsNotSimilar() {
    UserList userlist = new UserList();
    userlist.searchSimilarUser("F", "25", "4");
    Assert.assertTrue(userlist.isNotSimilar(2));
    Assert.assertFalse(userlist.isNotSimilar(1));
  }
}

package com.recommend.app;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
public class ApplicationTest {

  @Test
  public void contextLoads() {}
}

package com.recommend.app;

import com.recommend.utils.errors.MovieNotExistError;
import java.util.*;
import org.junit.Assert;
import org.junit.Test;

public class MovieListTest {

  List<String> genres = new ArrayList<String>();
  List<Integer> ids = new ArrayList<Integer>();
  Integer[] arrayid = new Integer[] { 34, 54, 66, 57, 1, 30, 888, 97, 14, 35 };
  String[] arrayname = new String[] {
    "Babe (1995)",
    "Big Green, The (1995)",
    "Lawnmower Man 2: Beyond Cyberspace (1996)",
    "Home for the Holidays (1995)",
    "Toy Story (1995)",
    "Shanghai Triad (Yao a yao yao dao waipo qiao) (1995)",
    "Land Before Time III: The Time of the Great Giving (1995)",
    "Hate (Haine, La) (1995)",
    "Nixon (1995)",
    "Carrington (1995)",
  };

  @Test(expected = MovieNotExistError.class)
  public void testMovieNotExistError() {
    genres.add("ABCDE");
    MovieList movie = new MovieList(genres);
  }

  @Test
  public void testGenreNotSpecifiedSearchID() {
    MovieList movie = new MovieList(genres);
    Assert.assertEquals(
      "testGenreNotSpecifiedSearchID",
      3883,
      movie.getMoviesID().size()
    );
  }

  @Test
  public void testEmptySearchID() {
    genres.add("");
    MovieList movie = new MovieList(genres);
    Assert.assertEquals("testEmptySearchID", 3883, movie.getMoviesID().size());
  }

  @Test
  public void testSearchID() {
    genres.add("Action");
    genres.add("Drama");
    MovieList movie = new MovieList(genres);
    Assert.assertEquals("testSearchID", 2006, movie.getMoviesID().size());
  }

  @Test
  public void testFindID() {
    genres.add("Action");
    genres.add("Drama");
    MovieList movie = new MovieList(genres);
    Assert.assertEquals("testFindID1", true, movie.findID(17));
    Assert.assertEquals("testFindID2", true, movie.findID(20));
    Assert.assertEquals("testFindID3", false, movie.findID(176));
  }

  @Test
  public void testEmptySearchName() {
    List<String> expected = new ArrayList<String>();
    MovieList movie = new MovieList(genres);
    movie.searchName(ids);
    Assert.assertEquals("testEmptySearchName", expected, movie.getMoviesName());
  }

  @Test
  public void testSearchName() {
    List<String> expected = new ArrayList<String>();
    expected.addAll(Arrays.asList(arrayname));
    ids.addAll(Arrays.asList(arrayid));
    MovieList movie = new MovieList(genres);
    movie.searchName(ids);
    Assert.assertEquals("testSearchNmae", expected, movie.getMoviesName());
  }

  @Test
  public void testBufferSearch() {
    List<String> expected = new ArrayList<String>();
    expected.addAll(Arrays.asList(arrayname));
    ids.addAll(Arrays.asList(arrayid));
    ids.add(3952);
    expected.add("Contender, The (2000)");
    MovieList movie = new MovieList(genres);
    movie.searchName(ids);
    Assert.assertEquals("testBufferSearch", expected, movie.getMoviesName());
  }

  @Test
  public void testSearchSimilarID() {
    MovieList movie = new MovieList();
    List<String> genres = new ArrayList<String>();
    genres.add("Romance");
    genres.add("Comedy");

    movie.searchSimilarID(genres);
    Assert.assertEquals(2, movie.similarMovies.size());
  }

  @Test
  public void testRegisterFavoriteMovie() {
    MovieList movie = new MovieList();
    movie.registerFavoriteMovie("Toy Story (1995)");

    Assert.assertEquals(3, movie.similarMovies.size());
    Assert.assertEquals(3, movie.countMathcedGenres(1));
  }
}

package com.recommend.app;

class AvgRating {

  int sum;
  int count;
  double average;

  public AvgRating(int sum, int count) {
    this.sum = sum;
    this.count = count;
  }

  public int getSum() {
    return this.sum;
  }

  public int getCount() {
    return this.count;
  }

  public double getAverage() {
    return this.average;
  }

  public void setAverage() {
    this.average = (double) (this.sum) / (this.count);
  }
}

package com.recommend.app;

class Rating implements Comparable<Rating> {

  int sum;
  int count;
  double average;
  int match;

  public Rating(int a, int b, int c) {
    this.sum = a;
    this.count = b;
    this.match = c;
    this.average = (double) a / b;
  }

  public int getSum() {
    return this.sum;
  }

  public int getCount() {
    return this.count;
  }

  public double getAverage() {
    return this.average;
  }

  public int getMatch() {
    return this.match;
  }

  @Override
  public int compareTo(Rating t) {
    if (this.match > t.getMatch()) {
      return 1;
    } else if (this.match < t.getMatch()) {
      return -1;
    } else {
      if (this.average > t.getAverage()) {
        return 1;
      } else if (this.average < t.getAverage()) {
        return -1;
      }
    }
    return 0;
  }
}

package com.recommend.app;

import java.util.*;

public class Movie {

  String title;
  String genres;
  String imdb;

  public Movie(String title, String genres, String imdb) {
    this.title = title;
    this.genres = genres;
    this.imdb = imdb;
  }

  public String getTitle() {
    return this.title;
  }

  public String getGenres() {
    return this.genres;
  }

  public String getImdb() {
    return this.imdb;
  }
}

package com.recommend.utils.errors;

import java.util.Arrays;

public class ArgCntError extends IllegalArgumentException {

  int number;
  String message = null;

  public ArgCntError(int argc) {
    number = argc;
    errMessage();
  }

  public void errMessage() {
    System.out.println("[ERROR : ArgCntError]");
    this.message =
      "[ERROR : ArgCntError] " +
      this.number +
      " is invalid number of arguments.";
  }

  public String getMessage() {
    return this.message;
  }
}

package com.recommend.utils.errors;

import com.recommend.app.Arguments;

public class WrongArgError extends IllegalArgumentException {

  String missingArg;
  String message;

  public WrongArgError(String type) {
    errMessage(type);
  }

  public void errMessage(String type) {
    System.out.println("[ERROR : WrongArgError]");
    if (type == "user") this.message =
      "[ERROR : WrongArgError] There is unknown argument. [Valid arguments : gender, age, occupation, genres(optional)]";
    else this.message =
      "[ERROR : WrongArgError] There is unknown argument. [Valid arguments : title, limit(optional)]";
  }

  public String getMessage() {
    return this.message;
  }
}

package com.recommend.utils.errors;

import java.util.List;

public class MovieNotExistError extends IllegalArgumentException {

  public List<String> selected_genres;
  public String selected_names;
  String message = null;

  public MovieNotExistError(List<String> genres) {
    selected_genres = genres;
    errorMessage();
  }

  public MovieNotExistError(String names) {
    selected_names = names;
    errorMessage(selected_names);
  }

  public void errorMessage() {
    System.out.println("[ERROR : MovieNotExistError]");
    this.message =
      "[ERROR : MovieNotExistError] Can't find any movie that belong to at least one selected genres: " +
      this.selected_genres;
  }

  public void errorMessage(String name) {
    System.out.println("[ERROR : MovieNotExistError]");
    this.message =
      "[ERROR : MovieNotExistError] Can't find a movie titled: " +
      this.selected_names;
  }

  public String getMessage() {
    return this.message;
  }
}

package com.recommend.utils.errors;

import com.recommend.app.Arguments;

public class ArgNotExistError extends IllegalArgumentException {

  String user_input;
  String processed_input;
  int argType;
  String message;

  public ArgNotExistError(Arguments args, int argType) {
    this.argType = argType;
    switch (argType) {
      case 1:
        user_input = args.getGender();
        break;
      case 2:
        user_input = args.getAge();
        break;
      case 3:
        user_input = args.getRawOccupation();
        break;
      default:
        user_input = args.getRawGenre();
        break;
    }
    processed_input = args.err_sender_str;
    errMessage();
  }

  public void errMessage() {
    System.out.println("[ERROR : ArgNotExistError]");
    switch (this.argType) {
      case 1:
        this.message =
          "[ERROR : ArgNotExistError] The gender should be F or M. [" +
          this.user_input +
          "] is invalid input.";
        break;
      case 2:
        this.message =
          "[ERROR : ArgNotExistError] The age should be greater than 0." +
          this.user_input +
          "] is invalid input.";
        break;
      case 3:
        this.message =
          "[ERROR : ArgNotExistError] Can't find [" +
          this.user_input +
          "] in the available occupation list.";
        break;
      default:
        this.message =
          "[ERROR : ArgNotExistError] The movie genre [" +
          this.user_input +
          "] is invalid. Can't find [" +
          this.processed_input +
          "] in the list.";
        break;
    }
  }

  public String getMessage() {
    return this.message;
  }
}

package com.recommend.utils.errors;

public class UserNotExistError extends IllegalArgumentException {

  public UserNotExistError() {
    super();
    errMessage();
  }

  public void errMessage() {
    System.out.println("[ERROR : UserNotExistError]");
    System.out.println("Can't find any corresponding user.");
    System.out.println(
      "-------------Program was forced to exit.-------------\n"
    );
  }
}

package com.recommend.utils.errors;

import com.recommend.app.Arguments;

public class ArgMissingError extends IllegalArgumentException {

  String missingArg;
  String message;

  public ArgMissingError(String missingArg) {
    this.missingArg = missingArg;
    errMessage();
  }

  public void errMessage() {
    System.out.println("[ERROR : ArgMissingError]");
    this.message =
      "[ERROR : ArgMissingError] The argument '" + missingArg + "' is missing.";
  }

  public String getMessage() {
    return this.message;
  }
}

package com.recommend.app;

import com.recommend.app.RatingCalculator;
import com.recommend.utils.errors.*;
import java.util.*;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

@RestController
public class UsersBasedRecommController {

  @GetMapping("/users/recommendations")
  public List<Movie> userBasedAPI(
    @RequestBody Map<String, String> requestBody
  ) {
    try {
      String gender = requestBody.get("gender");
      String age = requestBody.get("age");
      String occupation = requestBody.get("occupation");
      String genres = requestBody.get("genres");

      if (
        requestBody.size() <= 2 || requestBody.size() > 4
      ) throw new ArgCntError((Integer) requestBody.size());

      if (gender == null) throw new ArgMissingError("gender"); else if (
        age == null
      ) throw new ArgMissingError("age"); else if (
        occupation == null
      ) throw new ArgMissingError("occupation");

      Arguments arg;
      if (genres == null) {
        if (requestBody.size() == 4) throw new WrongArgError("user");
        arg = new Arguments(gender, age, occupation);
      } else arg = new Arguments(gender, age, occupation, genres);

      MovieList movielist = new MovieList(arg.getGenres());
      UserList userlist = new UserList();
      userlist.searchSimilarUser(
        arg.getGender(),
        arg.getAge(),
        arg.getOccupation()
      );
      RatingCalculator rating = new RatingCalculator(movielist, userlist);
      rating.rankUserBasedRating(10);
      rating.calcResult();
      return rating.getMoviesResult();
    } catch (MovieNotExistError e) {
      throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
    } catch (ArgNotExistError e) {
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
    } catch (ArgCntError e) {
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
    } catch (ArgMissingError e) {
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
    } catch (WrongArgError e) {
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
    }
  }
}

package com.recommend.app;

import com.recommend.app.RatingCalculator;
import com.recommend.utils.errors.*;
import java.util.*;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.server.ResponseStatusException;

@RestController
public class MovieBasedRecommController {

  @GetMapping("/movies/recommendations")
  public List<Movie> movieBasedAPI(
    @RequestBody Map<String, Object> requestBody
  ) {
    try {
      int bodysize = requestBody.size();
      if (bodysize == 0 || bodysize > 2) throw new ArgCntError(
        (Integer) bodysize
      );
      String title = (String) requestBody.get("title");
      if (title == null) throw new ArgMissingError("title");
      Integer limit = (Integer) requestBody.get("limit");
      if (limit == null) {
        if (bodysize == 2) throw new WrongArgError("movie");
        limit = 10;
      }

      MovieList movielist = new MovieList();
      UserList userlist = new UserList();

      movielist.registerFavoriteMovie(title);
      userlist.searchFavoriteUsers(title);

      RatingCalculator rating = new RatingCalculator(movielist, userlist);
      rating.rankGenreBasedRating(limit, true);
      if (rating.numMoviesResult() < limit) rating.rankGenreBasedRating(
        limit,
        false
      );
      rating.calcResult();
      return rating.getMoviesResult();
    } catch (MovieNotExistError e) {
      throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
    } catch (ArgCntError e) {
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
    } catch (ArgMissingError e) {
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
    } catch (WrongArgError e) {
      throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
    }
  }
}

package com.recommend.app;

import com.recommend.utils.errors.MovieNotExistError;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.util.*;

public class Tool {

  public static List<String> getMovieGenre(String name)
    throws MovieNotExistError {
    List<String> Genres = new ArrayList<String>();
    boolean isFind = false;
    String raw_name = null;
    raw_name =
      name
        .trim()
        .toLowerCase()
        .replaceAll("\\p{Z}", "")
        .replaceAll("\\p{Punct}", "");
    try {
      File moviefile = new File("./data/movies.dat");
      FileReader fileReader = new FileReader(moviefile);
      BufferedReader bufReader = new BufferedReader(fileReader);
      String data = "";
      while ((data = bufReader.readLine()) != null) {
        String[] temp = data.split("::");
        String raw_name2 = null;
        String raw_name3 = null;
        raw_name2 =
          temp[1].trim()
            .toLowerCase()
            .replaceAll("\\p{Z}", "")
            .replaceAll("\\p{Punct}", "");
        raw_name3 = raw_name2.substring(0, (raw_name2.length() - 4));
        if (raw_name.equals(raw_name2) || raw_name.equals(raw_name3)) {
          isFind = true;
          String[] temp_genres = temp[2].split("\\|");
          Genres.addAll(Arrays.asList(temp_genres));
          break;
        }
      }
      if (!isFind) {
        throw new MovieNotExistError(name);
      }
    } catch (IOException e) {}
    return Genres;
  }

  public static int getMovieID(String name) throws MovieNotExistError {
    int favoriteMovieID = 0;
    boolean isFind = false;
    String raw_name = null;
    raw_name =
      name
        .trim()
        .toLowerCase()
        .replaceAll("\\p{Z}", "")
        .replaceAll("\\p{Punct}", "");
    try {
      File moviefile = new File("./data/movies.dat");
      FileReader fileReader = new FileReader(moviefile);
      BufferedReader bufReader = new BufferedReader(fileReader);
      String data = "";
      while ((data = bufReader.readLine()) != null) {
        String[] temp = data.split("::");
        String raw_name2 = null;
        String raw_name3 = null;
        raw_name2 =
          temp[1].trim()
            .toLowerCase()
            .replaceAll("\\p{Z}", "")
            .replaceAll("\\p{Punct}", "");
        raw_name3 = raw_name2.substring(0, (raw_name2.length() - 4));
        if (raw_name.equals(raw_name2) || raw_name.equals(raw_name3)) {
          isFind = true;
          favoriteMovieID = Integer.parseInt(temp[0]);
          break;
        }
      }
      if (!isFind) {
        throw new MovieNotExistError(name);
      }
    } catch (IOException e) {}
    return favoriteMovieID;
  }
}

package com.recommend.app;

import java.io.*;
import java.util.*;

public class RatingCalculator {

  HashMap<Integer, Rating> map = new HashMap<>();
  LinkedHashMap<Integer, Rating> result = new LinkedHashMap<>();
  List<String> names;
  List<String> genres;
  List<Integer> ID;
  List moviesResult = new ArrayList<Movie>();
  MovieList movies;
  UserList users;

  public RatingCalculator(MovieList movieList, UserList userList) {
    this.movies = movieList;
    this.users = userList;
  }

  void rankUserBasedRating(int limit) {
    try {
      File usersFile = new File("./data/ratings.dat");
      FileReader reader = new FileReader(usersFile);
      BufferedReader buffer = new BufferedReader(reader);
      String line;
      int matched = 3;
      while ((line = buffer.readLine()) != null) {
        String[] rating = line.split("::");
        int user = Integer.parseInt(rating[0]);
        int movie = Integer.parseInt(rating[1]);
        if (users.isMatched(user)) {
          matched = 3;
        } else if (users.isSimilar(user)) {
          matched = 2;
        } else if (users.isLessSimilar(user)) {
          matched = 1;
        } else {
          matched = 0;
        }

        if (movies.findID(movie)) {
          if (map.containsKey(movie)) {
            if (map.get(movie).getMatch() == matched) {
              int tsum = map.get(movie).getSum() + Integer.parseInt(rating[2]);
              int tcount = map.get(movie).getCount() + 1;
              map.put(movie, new Rating(tsum, tcount, matched));
            } else if (map.get(movie).getMatch() < matched) {
              map.put(
                movie,
                new Rating(Integer.parseInt(rating[2]), 1, matched)
              );
            }
          } else {
            map.put(movie, new Rating(Integer.parseInt(rating[2]), 1, matched));
          }
        }
      }
    } catch (IOException e) {}

    List<Map.Entry<Integer, Rating>> entries = new LinkedList<>(map.entrySet());
    Collections.sort(
      entries,
      (o1, o2) -> o2.getValue().compareTo(o1.getValue())
    );

    for (Map.Entry<Integer, Rating> entry : entries) {
      if (result.size() < limit) result.put(
        entry.getKey(),
        entry.getValue()
      ); else break;
    }
  }

  void rankGenreBasedRating(int limit, boolean userfilter) {
    try {
      File usersFile = new File("./data/ratings.dat");
      FileReader reader = new FileReader(usersFile);
      BufferedReader buffer = new BufferedReader(reader);
      String line;

      while ((line = buffer.readLine()) != null) {
        String[] rating = line.split("::");
        int user = Integer.parseInt(rating[0]);
        int movie = Integer.parseInt(rating[1]);
        int match = movies.countMathcedGenres(movie);

        if (!userfilter || users.isFavorite(user)) {
          if (map.containsKey(movie)) {
            int tsum = map.get(movie).getSum() + Integer.parseInt(rating[2]);
            int tcount = map.get(movie).getCount() + 1;
            map.put(movie, new Rating(tsum, tcount, match));
          } else {
            map.put(movie, new Rating(Integer.parseInt(rating[2]), 1, match));
          }
        }
      }
      map.remove(movies.favoriteMovieID);
      if (!userfilter) {
        List<Integer> keys = new ArrayList<>(result.keySet());
        for (Integer key : keys) {
          map.remove(key);
        }
      }
    } catch (IOException e) {}

    List<Map.Entry<Integer, Rating>> entries = new LinkedList<>(map.entrySet());
    Collections.sort(
      entries,
      (o1, o2) -> o2.getValue().compareTo(o1.getValue())
    );

    for (Map.Entry<Integer, Rating> entry : entries) {
      if (result.size() < limit) result.put(
        entry.getKey(),
        entry.getValue()
      ); else break;
    }
  }

  public void calcResult() {
    String moviename = "";
    String moviegenre = "";
    String movielink = "";
    int i = 0;
    ID = new ArrayList<>(result.keySet());
    movies.searchName(ID);
    names = movies.getMoviesName();
    genres = movies.getMovieGenres();

    try {
      for (Integer key : result.keySet()) {
        File linkfile = new File("./data/links.dat");
        FileReader fileReader = new FileReader(linkfile);
        BufferedReader bufReader = new BufferedReader(fileReader);
        String data = "";

        moviename = names.get(i);
        moviegenre = genres.get(i);
        i += 1;

        while ((data = bufReader.readLine()) != null) {
          String[] temp = data.split("::");
          if (key == Integer.parseInt(temp[0])) {
            movielink = temp[1];
            break;
          }
        }
        Movie movie = new Movie(
          moviename,
          moviegenre,
          "(http://www.imdb.com/title/tt" + movielink + ")"
        );
        this.moviesResult.add(movie);
      }
    } catch (IOException e) {}
  }

  public List getMoviesResult() {
    return this.moviesResult;
  }

  public int numMoviesResult() {
    return this.result.size();
  }
}

package com.recommend.app;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class Application {

  public static void main(String[] args) {
    SpringApplication.run(Application.class, args);
  }
}

package com.recommend.app;

import com.recommend.utils.errors.UserNotExistError;
import java.io.*;
import java.util.*;

public class UserList {

  TreeSet<Integer> matchedUsers = new TreeSet<Integer>();
  TreeSet<Integer> mostSimUsers = new TreeSet<Integer>();
  TreeSet<Integer> lessSimUsers = new TreeSet<Integer>();
  TreeSet<Integer> notSimUsers = new TreeSet<Integer>();
  TreeSet<Integer> favoriteUsers = new TreeSet<Integer>();

  void searchMatchedUser(int occupation) throws UserNotExistError {
    try {
      File usersFile = new File("./data/users.dat");
      FileReader reader = new FileReader(usersFile);
      BufferedReader buffer = new BufferedReader(reader);
      String line;
      while ((line = buffer.readLine()) != null) {
        String[] user = line.split("::");
        if (Integer.parseInt(user[3]) == occupation) {
          matchedUsers.add(Integer.parseInt(user[0]));
        }
      }
      if (matchedUsers.isEmpty()) throw new UserNotExistError();
    } catch (IOException e) {}
  }

  void searchSimilarUser(String gender, String age, String occupation) {
    boolean genderEmpty = gender.isEmpty();
    boolean ageEmpty = age.isEmpty();
    boolean occupationEmpty = occupation.isEmpty();

    try {
      File usersFile = new File("./data/users.dat");
      FileReader reader = new FileReader(usersFile);
      BufferedReader buffer = new BufferedReader(reader);
      String line;
      while ((line = buffer.readLine()) != null) {
        String[] user = line.split("::");
        int numMatched =
          (genderEmpty || user[1].equals(gender) ? 1 : 0) +
          (ageEmpty || user[2].equals(age) ? 1 : 0) +
          (occupationEmpty || user[3].equals(occupation) ? 1 : 0);
        switch (numMatched) {
          case 1:
            lessSimUsers.add(Integer.parseInt(user[0]));
            continue;
          case 2:
            mostSimUsers.add(Integer.parseInt(user[0]));
            continue;
          case 3:
            matchedUsers.add(Integer.parseInt(user[0]));
            continue;
          default:
            notSimUsers.add(Integer.parseInt(user[0]));
            continue;
        }
      }
    } catch (IOException e) {}
  }

  void searchFavoriteUsers(String title) {
    HashMap<Integer, Integer> users = new HashMap<Integer, Integer>();
    HashMap<Integer, AvgRating> usersAvg = new HashMap<Integer, AvgRating>();
    int MovieID = Tool.getMovieID(title);
    try {
      File ratingFile = new File("./data/ratings.dat");
      FileReader reader = new FileReader(ratingFile);
      BufferedReader buffer = new BufferedReader(reader);
      String line;
      while ((line = buffer.readLine()) != null) {
        String[] rating = line.split("::");
        if (Integer.parseInt(rating[1]) == MovieID) {
          users.put(Integer.parseInt(rating[0]), Integer.parseInt(rating[2]));
        }
      }
    } catch (IOException e) {}
    try {
      File ratingFile = new File("./data/ratings.dat");
      FileReader reader = new FileReader(ratingFile);
      BufferedReader buffer = new BufferedReader(reader);
      String line;
      while ((line = buffer.readLine()) != null) {
        String[] rating = line.split("::");
        if (users.containsKey(Integer.parseInt(rating[0]))) {
          if (usersAvg.containsKey(Integer.parseInt(rating[0]))) {
            AvgRating temp = new AvgRating(
              (
                usersAvg.get(Integer.parseInt(rating[0])).getSum() +
                Integer.parseInt(rating[2])
              ),
              (usersAvg.get(Integer.parseInt(rating[0])).getCount() + 1)
            );
            temp.setAverage();
            usersAvg.replace(Integer.parseInt(rating[0]), temp);
          } else {
            AvgRating temp = new AvgRating(Integer.parseInt(rating[2]), 1);
            temp.setAverage();
            usersAvg.put(Integer.parseInt(rating[0]), temp);
          }
        }
      }

      for (Integer key : users.keySet()) {
        if (users.get(key) >= usersAvg.get(key).getAverage()) {
          favoriteUsers.add(key);
        }
      }
    } catch (IOException e) {}
  }

  public boolean isMatched(int userid) {
    return matchedUsers.contains(userid);
  }

  public boolean isSimilar(int userid) {
    return mostSimUsers.contains(userid);
  }

  public boolean isLessSimilar(int userid) {
    return lessSimUsers.contains(userid);
  }

  public boolean isNotSimilar(int userid) {
    return notSimUsers.contains(userid);
  }

  public boolean isFavorite(int userid) {
    return favoriteUsers.contains(userid);
  }
}

package com.recommend.app;

import com.recommend.utils.errors.MovieNotExistError;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Array;
import java.util.*;

public class MovieList {

  TreeSet<Integer> movies = new TreeSet<Integer>();
  List<String> movieName = new ArrayList<String>();
  List<String> movieGenres = new ArrayList<String>();
  List<String> favoriteGenres = new ArrayList<String>();
  List<TreeSet<Integer>> similarMovies = new ArrayList<TreeSet<Integer>>();
  Integer favoriteMovieID;

  public MovieList() {}

  public MovieList(List<String> genres) {
    searchID(genres);
  }

  void searchID(List<String> genres) throws MovieNotExistError {
    int genres_num = genres.size();
    try {
      File moviefile = new File("./data/movies.dat");
      FileReader fileReader = new FileReader(moviefile);
      BufferedReader bufReader = new BufferedReader(fileReader);
      String data = "";
      while ((data = bufReader.readLine()) != null) {
        String[] temp = data.split("::");
        if (genres.isEmpty() || genres.contains("")) {
          movies.add(Integer.parseInt(temp[0]));
        } else {
          for (int i = 0; i < genres_num; i++) {
            if (temp[2].contains(genres.get(i))) {
              movies.add(Integer.parseInt(temp[0]));
              break;
            }
          }
        }
      }
      if (!movies.isEmpty()) {
        return;
      }
      throw new MovieNotExistError(genres);
    } catch (IOException e) {}
  }

  public boolean findID(int MovieID) {
    return movies.contains(MovieID);
  }

  public TreeSet<Integer> getMoviesID() {
    return movies;
  }

  public void searchName(List<Integer> ID) {
    try {
      Integer[] ids = new Integer[ID.size()];
      String[] names = new String[ID.size()];
      String[] genres = new String[ID.size()];
      File moviefile = new File("./data/movies.dat");
      FileReader fileReader = new FileReader(moviefile);
      BufferedReader bufReader = new BufferedReader(fileReader);
      String data = "";
      for (
        int i = 0;
        ((data = bufReader.readLine()) != null) && i < ID.size();
      ) {
        String[] temp = data.split("::");
        if (ID.contains(Integer.parseInt(temp[0]))) {
          ids[i] = Integer.parseInt(temp[0]);
          names[i] = temp[1];
          genres[i] = temp[2];
          i++;
        }
      }
      if (ID.size() != 0) {
        for (int j = 0; j < ID.size(); j++) {
          int index = Arrays.asList(ids).indexOf(ID.get(j));
          movieName.add(names[index]);
          movieGenres.add(genres[index]);
        }
      }
    } catch (IOException e) {}
  }

  public List<String> getMoviesName() {
    return movieName;
  }

  public List<String> getMovieGenres() {
    return movieGenres;
  }

  public void searchSimilarID(List<String> genres) {
    try {
      int genres_num = genres.size();
      for (int i = 0; i < genres_num; i++) similarMovies.add(
        new TreeSet<Integer>()
      );
      File moviefile = new File("./data/movies.dat");
      FileReader fileReader = new FileReader(moviefile);
      BufferedReader bufReader = new BufferedReader(fileReader);
      String data = "";
      while ((data = bufReader.readLine()) != null) {
        int count = 0;
        String[] temp = data.split("::");
        for (int i = 0; i < genres_num; i++) {
          if (temp[2].contains(genres.get(i))) {
            count++;
          }
        }
        if (count > 0) {
          similarMovies.get(count - 1).add(Integer.parseInt(temp[0]));
        }
      }
    } catch (IOException e) {}
  }

  public void registerFavoriteMovie(String title) {
    this.favoriteGenres = Tool.getMovieGenre(title);
    this.favoriteMovieID = Tool.getMovieID(title);
    searchSimilarID(favoriteGenres);
  }

  public int countMathcedGenres(int movieID) {
    int match = 0;
    for (int i = 0; i < favoriteGenres.size(); i++) {
      if (similarMovies.get(i).contains(movieID)) match = i + 1;
    }
    return match;
  }
}

package com.recommend.app;

import com.recommend.utils.errors.ArgNotExistError;
import java.util.*;

public class Arguments {

  String gender;
  String age;
  String occupation;
  List<String> genres = new ArrayList<String>();

  String raw_occupation = null;
  String raw_genres = null;
  public String err_sender_str = null;

  static final Map<String, String> GENRE_MAP = new HashMap<String, String>();
  static final Map<String, Integer> OCCUPATIONS_MAP = new HashMap<String, Integer>();

  public Arguments() {}

  public Arguments(String arg1, String arg2, String arg3) {
    setMap();
    setArgs(arg1, arg2, arg3);
    parseGender();
    parseAge();
    parseOccupation();
  }

  public Arguments(String arg1, String arg2, String arg3, String arg4) {
    setMap();
    setArgs(arg1, arg2, arg3, arg4);
    parseGender();
    parseAge();
    parseOccupation();
    parseGenres();
  }

  void setMap() {
    OCCUPATIONS_MAP.put("other", 0);
    OCCUPATIONS_MAP.put("academic/educator", 1);
    OCCUPATIONS_MAP.put("academiceducator", 1);
    OCCUPATIONS_MAP.put("academic", 1);
    OCCUPATIONS_MAP.put("educator", 1);
    OCCUPATIONS_MAP.put("artist", 2);
    OCCUPATIONS_MAP.put("clerical/admin", 3);
    OCCUPATIONS_MAP.put("clericaladmin", 3);
    OCCUPATIONS_MAP.put("clerical", 3);
    OCCUPATIONS_MAP.put("admin", 3);
    OCCUPATIONS_MAP.put("college/gradstudent", 4);
    OCCUPATIONS_MAP.put("collegegradstudent", 4);
    OCCUPATIONS_MAP.put("collegestudent", 4);
    OCCUPATIONS_MAP.put("gradstudent", 4);
    OCCUPATIONS_MAP.put("customerservice", 5);
    OCCUPATIONS_MAP.put("doctor/healthcare", 6);
    OCCUPATIONS_MAP.put("doctorhealthcare", 6);
    OCCUPATIONS_MAP.put("doctor", 6);
    OCCUPATIONS_MAP.put("healthcare", 6);
    OCCUPATIONS_MAP.put("executive/managerial", 7);
    OCCUPATIONS_MAP.put("executivemanagerial", 7);
    OCCUPATIONS_MAP.put("executive", 7);
    OCCUPATIONS_MAP.put("managerial", 7);
    OCCUPATIONS_MAP.put("farmer", 8);
    OCCUPATIONS_MAP.put("homemaker", 9);
    OCCUPATIONS_MAP.put("k-12student", 10);
    OCCUPATIONS_MAP.put("k12student", 10);
    OCCUPATIONS_MAP.put("lawyer", 11);
    OCCUPATIONS_MAP.put("programmer", 12);
    OCCUPATIONS_MAP.put("retired", 13);
    OCCUPATIONS_MAP.put("sales/marketing", 14);
    OCCUPATIONS_MAP.put("salesmarketing", 14);
    OCCUPATIONS_MAP.put("sales", 14);
    OCCUPATIONS_MAP.put("marketing", 14);
    OCCUPATIONS_MAP.put("scientist", 15);
    OCCUPATIONS_MAP.put("self-employed", 16);
    OCCUPATIONS_MAP.put("selfemployed", 16);
    OCCUPATIONS_MAP.put("technician/engineer", 17);
    OCCUPATIONS_MAP.put("technicianengineer", 17);
    OCCUPATIONS_MAP.put("technician", 17);
    OCCUPATIONS_MAP.put("engineer", 17);
    OCCUPATIONS_MAP.put("tradesman/craftsman", 18);
    OCCUPATIONS_MAP.put("tradesmancraftsman", 18);
    OCCUPATIONS_MAP.put("tradesman", 18);
    OCCUPATIONS_MAP.put("craftsman", 18);
    OCCUPATIONS_MAP.put("unemployed", 19);
    OCCUPATIONS_MAP.put("writer", 20);

    GENRE_MAP.put("action", "Action");
    GENRE_MAP.put("adventure", "Adventure");
    GENRE_MAP.put("animation", "Animation");
    GENRE_MAP.put("children's", "Children's");
    GENRE_MAP.put("comedy", "Comedy");
    GENRE_MAP.put("crime", "Crime");
    GENRE_MAP.put("documentary", "Documentary");
    GENRE_MAP.put("drama", "Drama");
    GENRE_MAP.put("fantasy", "Fantasy");
    GENRE_MAP.put("film-noir", "Film-Noir");
    GENRE_MAP.put("filmnoir", "Film-Noir");
    GENRE_MAP.put("horror", "Horror");
    GENRE_MAP.put("musical", "Musical");
    GENRE_MAP.put("mystery", "Mystery");
    GENRE_MAP.put("romance", "Romance");
    GENRE_MAP.put("sci-fi", "Sci-Fi");
    GENRE_MAP.put("scifi", "Sci-Fi");
    GENRE_MAP.put("thriller", "Thriller");
    GENRE_MAP.put("war", "War");
    GENRE_MAP.put("western", "Western");
  }

  void setArgs(String arg1, String arg2, String arg3) {
    this.gender = arg1;
    this.age = arg2;
    this.raw_occupation = arg3;
  }

  void setArgs(String arg1, String arg2, String arg3, String arg4) {
    this.gender = arg1;
    this.age = arg2;
    this.raw_occupation = arg3;
    this.raw_genres = arg4;
  }

  void parseGender() throws ArgNotExistError {
    if (
      this.gender.toUpperCase().equals("F") ||
      this.gender.toUpperCase().equals("M") ||
      this.gender.toUpperCase().equals("")
    ) this.gender = this.gender.toUpperCase(); else throw new ArgNotExistError(
      this,
      1
    );
  }

  void parseAge() throws ArgNotExistError {
    if (this.age.equals("")) return; else {
      int ageToNum = Integer.parseInt(this.age);
      if (ageToNum >= 0 && ageToNum < 18) this.age = "1"; else if (
        ageToNum >= 18 && ageToNum <= 24
      ) this.age = "18"; else if (ageToNum >= 25 && ageToNum <= 34) this.age =
        "25"; else if (ageToNum >= 35 && ageToNum <= 44) this.age =
        "35"; else if (ageToNum >= 45 && ageToNum <= 49) this.age =
        "45"; else if (ageToNum >= 50 && ageToNum <= 55) this.age =
        "50"; else if (ageToNum >= 56) this.age =
        "56"; else throw new ArgNotExistError(this, 2);
    }
  }

  void parseOccupation() throws ArgNotExistError {
    String st1 = raw_occupation;
    if (st1.equals("")) {
      this.occupation = "";
    } else {
      st1 = st1.trim().toLowerCase().replaceAll("\\p{Z}", "");

      if (!OCCUPATIONS_MAP.containsKey(st1)) {
        this.err_sender_str = st1;
        throw new ArgNotExistError(this, 3);
      } else {
        this.occupation =
          Integer.toString(
            OCCUPATIONS_MAP.get(
              st1.trim().toLowerCase().replaceAll("\\p{Z}", "")
            )
          );
      }
    }
  }

  void parseGenres() throws ArgNotExistError {
    String st1 = raw_genres;

    if (st1.equals("")) {
      return;
    } else {
      StringTokenizer gen_st = new StringTokenizer(st1, "|");
      while (gen_st.hasMoreTokens()) {
        this.genres.add(
            gen_st.nextToken().trim().toLowerCase().replaceAll("\\p{Z}", "")
          );
      }
      for (int i = 0; i < genres.size(); i++) {
        String genre = genres.get(i);
        if (!GENRE_MAP.containsKey(genre)) {
          this.err_sender_str = genre;
          throw new ArgNotExistError(this, 4);
        } else {
          genres.set(i, GENRE_MAP.get(genre));
        }
      }
    }
  }

  void printArgs() {
    System.out.println("*** arg 1 : " + this.gender + " ***");
    System.out.println("*** arg 2 : " + this.age + " ***");
    System.out.println("*** arg 3 : " + this.occupation + " ***");
    System.out.println("*** arg 4 : " + this.genres + " ***");
  }

  public String getGender() {
    return this.gender;
  }

  public String getAge() {
    return this.age;
  }

  public String getOccupation() {
    return this.occupation;
  }

  public List<String> getGenres() {
    return this.genres;
  }

  public String getRawOccupation() {
    return this.raw_occupation;
  }

  public String getRawGenre() {
    return this.raw_genres;
  }
}

